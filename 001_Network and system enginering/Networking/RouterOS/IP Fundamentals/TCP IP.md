---
Category: Information
tags:
  - information
  - open
---
---
###### External links
- 
---
## Description
Протокол TCP ориентированый на соединение (connection-oriented protocol). Разница между таким и connection-less протоколом, что этот не начнёт передавать данные пока надлежащее соединение не будет установлено (connection is established).

---
## TCP IP
##### Начальный номер последовательности
*Начальный номер последовательности выбирается отправителем случайно, и добавляет единицу на каждый байт, и в АККе ждёт всегда +1 номер.*
###### Пример
- Клиент устанавливает соединение с сервером.
- Клиент выбирает случайный `Seq=X=123456789`.
- Первый байт, который он отправляет, будет иметь номер `123456789`.
- Если он отправляет `"Hello"` (5 байт), следующий сегмент начнётся с `Seq=123456794`.

### TCP Session Establishment and Termination
Каждый раз как кто-то с удалённым узлом пытается установить соединение tcp, в протоколе используется трёхсторонее рукопожатие. Создаётся логическая сквозная сеть, которая используется для подтверждения надёжной доставки. *Имеет несколько типов сообщений в этих процесах.*

#### Connection establishment process
![[tcp-connection-establishment 1.jpg]]

1. Хост, который хочет установить соединение, отправляет пакет SYN с предложенным начальным порядковым номером (*начальный номер последовательности* - seq).
2. Когда хост В получает СИН, то он в ответ отправляет тсп пакет в заголовке с SYN и ACK (Acknowledgment).
3. Когда хост А получает син+ак, то он отправляяет подтверждение пакетом ACK и когда хост В получает его то соединение установлено.

*Connection-oriented protocol службы обычно отправляют АКК после успешной доставки. И по сути обычно когда хост отправляет инфу, всегда ждёт АККа, если он не приходит то он отправляет повторно свой пакет.*

##### Пример тройного рукопожатия с номерами:
1. Клиент → Сервер: SYN, Seq=1000
2. Сервер → Клиент: SYN-ACK, Seq=3000, ACK=1001
3. Клиент → Сервер: ACK, Seq=1001, ACK=3001

#### Connection termination
![[tcp-connection-termination 1.jpg]]

Ну тут уже изпользуется 4-стороннее рпукопожатие, по идее я так понимаю что бы вторая сторона еще могла не кидать ФИН а еще свою дату понакидывать и потом закрыть, не уверен.

1. Ну хоста А кидает ФИН и ждёт АКа.
2. Хост В получается переходит в состояние "passive close" (CLOSE_WAIT), отправляет АКК и если у него нет данных для передачи то получается отправляет тоже ФИН и получается входит в состояние LAST_ACK.
3. Когда хост А получит ФИН, он перейдёт в состояние TIME_WAIT и отправит ласт АКК, хост В получит его и соединение разорвется.

#### TCP Segments transmission (windowing)
Вся дата которая отправляется получателю, сохраняется у него в своём ограниченом буфере. Если накидывать ему инфы в буфер и он будет не успевать ее обрабатывать, и буфер заполнится то он начнёт ее дропать, а источник начнёт посылать потворно, что будет уменьшением продуктивности передачи.

После того как соединение установлено, то принимающий указывает размер, который он себе может еще впихнуть в буфер - размер окна (в байтах), и отправляется всегда в АККе.

Когда отправитель получит нулевое окно, то он прекратит передачу, пока не получит уведомление об увеличении окна.

##### Пример:
![[tcp-flow-control-using-windowing.jpg]]



---
## Notes


---
